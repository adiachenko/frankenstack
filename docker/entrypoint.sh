#!/bin/bash
set -e

is_ext_enabled() {
    local value="$1"
    [[ "${value,,}" =~ ^(1|true|yes|on)$ ]]
}

is_ext_disabled() {
    local value="$1"
    [[ "${value,,}" =~ ^(0|false|no|off)$ ]]
}

is_supported_node_version() {
    case "$1" in
        22|24) return 0 ;;
        *) return 1 ;;
    esac
}

setup_node_version() {
    if ! is_supported_node_version "$NODE_VERSION"; then
        echo "ERROR: Invalid NODE_VERSION '$NODE_VERSION'." >&2
        exit 1
    fi

    local node_bin="/opt/node/${NODE_VERSION}/bin"
    ln -sf "${node_bin}/node" /usr/local/bin/node
    ln -sf "${node_bin}/npm" /usr/local/bin/npm
    ln -sf "${node_bin}/npx" /usr/local/bin/npx
    setup_corepack "$node_bin"
}

# Corepack is bundled through Node.js 24 and dropped in later majors per official Node.js release notes.
node_supports_corepack() {
    [[ "$NODE_VERSION" =~ ^[0-9]+$ ]] && [ "$NODE_VERSION" -le 24 ]
}

setup_corepack() {
    local node_bin="$1"

    if node_supports_corepack; then
        local corepack_bin="${node_bin}/corepack"
        ln -sf "$corepack_bin" /usr/local/bin/corepack
        "$corepack_bin" enable
    fi
}

apply_timeouts() {
    export PHP_MAX_EXECUTION_TIME="$REQUEST_TIMEOUT"
    export CADDY_READ_TIMEOUT="$((REQUEST_TIMEOUT + 5))s"
    export CADDY_WRITE_TIMEOUT="$((REQUEST_TIMEOUT + 10))s"
}

resolve_frankenphp_mode() {
    local mode="${FRANKENPHP_MODE:-classic}"

    if [ "$mode" = "worker" ] && [ ! -f "$FRANKENPHP_WORKER" ]; then
        echo "WARNING: Worker mode requested but $FRANKENPHP_WORKER not found. Running in classic mode."
        mode="classic"
    fi

    # Unset $_SERVER['FRANKENPHP_WORKER'] in classic mode to prevent Symfony from incorrectly detecting worker
    if [ "$mode" = "classic" ]; then
        unset FRANKENPHP_WORKER
    fi

    export FRANKENPHP_MODE="$mode"
}

apply_frankenphp_mode_defaults() {
    local mode="${FRANKENPHP_MODE:-classic}"

    if [ -z "${PHP_XDEBUG_START_WITH_REQUEST:-}" ]; then
        if [ "$mode" = "worker" ]; then
            export PHP_XDEBUG_START_WITH_REQUEST="trigger"
        else
            export PHP_XDEBUG_START_WITH_REQUEST="yes"
        fi
    fi

    if [ -z "${PHP_XDEBUG_START_UPON_ERROR:-}" ]; then
        if [ "$mode" = "worker" ]; then
            export PHP_XDEBUG_START_UPON_ERROR="default"
        else
            export PHP_XDEBUG_START_UPON_ERROR="yes"
        fi
    fi
}

configure_php_extensions() {
    local ini_file="$PHP_INI_DIR/conf.d/40-extensions.ini"
    local extensions=""
    local all_enabled=false

    is_ext_enabled "${PHP_EXT_ALL:-}" && all_enabled=true

    # Alphabetical list of opt-in extensions (heavy/specialized, disabled by default)
    local opt_in="bz2 ffi ftp gd imagick intl ldap memcached mongodb sockets uv"

    for ext in $opt_in; do
        local var_name="PHP_EXT_${ext^^}"
        local value="${!var_name:-}"

        # Enable if: individual var is on, OR (all enabled AND not explicitly disabled)
        if is_ext_enabled "$value" || { $all_enabled && ! is_ext_disabled "$value"; }; then
            extensions+="extension=${ext}\n"
        fi
    done

    # Xdebug is a zend_extension (same logic)
    if is_ext_enabled "${PHP_EXT_XDEBUG:-}" || { $all_enabled && ! is_ext_disabled "${PHP_EXT_XDEBUG:-}"; }; then
        extensions+="zend_extension=xdebug\n"
    else
        # Remove xdebug config template if extension disabled
        rm -f "$PHP_INI_DIR/conf.d/30-xdebug.ini.tpl"
    fi

    printf "; Generated by entrypoint.sh\n%b" "$extensions" > "$ini_file"
}

apply_php_env_defaults() {
    local env="${PHP_ENV:-production}"

    case "$env" in
        production|development) ;;
        *)
            echo "WARNING: Unknown PHP_ENV '$env'. Falling back to production."
            env="production"
            ;;
    esac

    export PHP_ENV="$env"

    if [ -z "${PHP_DISPLAY_ERRORS:-}" ]; then
        if [ "$env" = "development" ]; then
            export PHP_DISPLAY_ERRORS="on"
        else
            export PHP_DISPLAY_ERRORS="off"
        fi
    fi

    if [ -z "${PHP_DISPLAY_STARTUP_ERRORS:-}" ]; then
        if [ "$env" = "development" ]; then
            export PHP_DISPLAY_STARTUP_ERRORS="on"
        else
            export PHP_DISPLAY_STARTUP_ERRORS="off"
        fi
    fi

    if [ -z "${PHP_ERROR_REPORTING:-}" ]; then
        if [ "$env" = "development" ]; then
            export PHP_ERROR_REPORTING="E_ALL"
        else
            export PHP_ERROR_REPORTING="E_ALL & ~E_DEPRECATED"
        fi
    fi

    if [ -z "${PHP_XDEBUG_MODE:-}" ]; then
        if [ "$env" = "development" ]; then
            export PHP_XDEBUG_MODE="debug,develop"
        else
            export PHP_XDEBUG_MODE="off"
        fi
    fi

    if [ -z "${PHP_OPCACHE_VALIDATE_TIMESTAMPS:-}" ]; then
        if [ "$env" = "development" ]; then
            export PHP_OPCACHE_VALIDATE_TIMESTAMPS="1"
        else
            export PHP_OPCACHE_VALIDATE_TIMESTAMPS="0"
        fi
    fi

    if [ -z "${FRANKENPHP_WORKER_WATCH:-}" ]; then
        if [ "$env" = "development" ]; then
            export FRANKENPHP_WORKER_WATCH="$(cat <<'EOF'
/opt/project/**/*.php
/opt/project/**/*.{yaml,yml}
/opt/project/.env*
EOF
)"
        else
            export FRANKENPHP_WORKER_WATCH=""
        fi
    fi
}

process_php_conf_templates() {
    local conf_dir="$PHP_INI_DIR/conf.d"

    for tpl in "$conf_dir"/*.tpl; do
        if [ -f "$tpl" ]; then
            local ini="${tpl%.tpl}"
            envsubst < "$tpl" > "$ini"
            rm -f "$tpl"
        fi
    done
}

setup_ssh() {
    local ssh_dir="/root/.ssh"

    # Skip if no SSH configuration present
    if [ -z "${SSH_AUTH_SOCK:-}" ] && [ ! -f "/run/secrets/ssh_key" ]; then
        return 0
    fi

    mkdir -p "$ssh_dir"
    chmod 700 "$ssh_dir"
    setup_ssh_known_hosts "$ssh_dir"

    # Use agent forwarding if available, otherwise load from secret
    if [ -n "${SSH_AUTH_SOCK:-}" ] && [ -S "${SSH_AUTH_SOCK}" ] && ssh-add -l >/dev/null 2>&1; then
        echo "SSH: Using forwarded agent ($(ssh-add -l 2>/dev/null | wc -l | xargs) keys)"
    elif [ -f "/run/secrets/ssh_key" ]; then
        setup_ssh_from_docker_secret
    fi
}

setup_ssh_known_hosts() {
    local ssh_dir="$1"
    local known_hosts="$ssh_dir/known_hosts"

    # Prefer mounted known_hosts
    if [ -f "/run/secrets/ssh_known_hosts" ]; then
        cp /run/secrets/ssh_known_hosts "$known_hosts"
        chmod 644 "$known_hosts"
        echo "SSH: Using mounted known_hosts"
        return 0
    fi

    # Fallback: ssh-keyscan for common hosts
    if [ -n "${SSH_KNOWN_HOSTS:-}" ]; then
        local IFS=','
        for host in $SSH_KNOWN_HOSTS; do
            host=$(echo "$host" | xargs)
            [ -n "$host" ] && ssh-keyscan -H "$host" >> "$known_hosts" 2>/dev/null
        done
        chmod 644 "$known_hosts"
    fi
}

setup_ssh_from_docker_secret() {
    local socket_path="/tmp/ssh-agent.sock"
    rm -f "$socket_path"
    ssh-agent -a "$socket_path" >/dev/null
    export SSH_AUTH_SOCK="$socket_path"

    local passphrase="${SSH_KEY_PASSPHRASE:-}"

    if [ -n "$passphrase" ]; then
        local askpass="/tmp/ssh_askpass_$$"
        printf '#!/bin/sh\necho "%s"\n' "$passphrase" > "$askpass"
        chmod 700 "$askpass"

        SSH_ASKPASS="$askpass" SSH_ASKPASS_REQUIRE=force \
            ssh-add /run/secrets/ssh_key </dev/null 2>/dev/null

        rm -f "$askpass"
    else
        ssh-add /run/secrets/ssh_key 2>/dev/null
    fi

    echo "SSH: Agent started with $(ssh-add -l 2>/dev/null | wc -l | xargs) key(s)"
}

# Parse watch patterns: one pattern per line, supports # comments
parse_watch_patterns() {
    local input="$1"

    while IFS= read -r line || [[ -n "$line" ]]; do
        line=$(printf '%s' "$line" | xargs)
        [[ -z "$line" || "$line" == \#* ]] && continue
        echo "$line"
    done <<< "$input"
}

setup_worker_mode() {
    [ "${FRANKENPHP_MODE:-classic}" = "worker" ] || return 0

    local worker_filename="${FRANKENPHP_WORKER##*/}"
    local watch_config=""
    local max_requests_config=""

    if [ -n "${FRANKENPHP_MAX_REQUESTS:-}" ]; then
        if [[ "$FRANKENPHP_MAX_REQUESTS" =~ ^[0-9]+$ ]] && [ "$FRANKENPHP_MAX_REQUESTS" -gt 0 ]; then
            max_requests_config="max_requests $FRANKENPHP_MAX_REQUESTS"
        fi
    fi
    if [ -n "$FRANKENPHP_WORKER_WATCH" ]; then
        while IFS= read -r pattern; do
            pattern=$(echo "$pattern" | xargs)
            if [ -n "$pattern" ]; then
                [ -n "$watch_config" ] && watch_config+=$'\n'"        "
                watch_config+="watch \"$pattern\""
            fi
        done < <(parse_watch_patterns "$FRANKENPHP_WORKER_WATCH")
    fi

    export FRANKENPHP_WORKER_CONFIG="worker {
        file \"$FRANKENPHP_WORKER\"
        $max_requests_config
        $watch_config
    }"

    export PHP_SERVER_CONFIG="index $worker_filename
        try_files {path} $worker_filename
        resolve_root_symlink"
}

main() {
    setup_node_version
    apply_timeouts
    resolve_frankenphp_mode
    apply_php_env_defaults
    apply_frankenphp_mode_defaults
    configure_php_extensions
    process_php_conf_templates
    setup_ssh
    setup_worker_mode

    # If a command is passed and it's not a frankenphp flag, run it directly (e.g. composer install)
    if [ $# -gt 0 ] && [ "${1#-}" = "$1" ]; then
        exec "$@"
    fi

    exec frankenphp run "$@"
}

main "$@"
